# Hands-On 2: Static Modules
This hands-on covers the creating of a DCAF Static module, this modules are easier to create and the recommended option if the module developer knows the number of channels that the module will require.
It is recommended that the Hands-On 1 is completed before doing this one.


## Introduction:

DCAF Static modules are simple custom modules that are easy to create with the restriction that the module developer needs to know the number of channels that the module will have. By having the known number of channels, DCAF contain useful scripting tools that simplifies the module development.

Before creating a DCAF Static module there is an important checklist to cover:

- Is there a module that already covers this functionality?
- Is this a static or a dynamic module?
- What inputs or outputs my module needs?

In each exercise will go through this checklist during the module definition, and a more on how to define DCAF modules can be found in the DCAF developer guide in section 4.


## Exercise 1:
In this exercise we will create a DCAF Static module that contains a custom PID control for our application.

#### Concepts Covered:
- Static Module Creation
- Basic Static Module overrides
- Static channel Configuration
- Working with the User Process VI
- Static Module Scripting


#### Module Definition:
This is processing module that will contain a single PID. Initially it will have some values hardcoded and will be updated to change so they can be updated by the engine.
- Is there a module that already covers this functionality?
In this case yes there is a PID module for DCAF that could be used, but as we want to go with the exercise we are going to ignore it.
-Is this a static or dynamic modules?
The module only needs 1 pid, and we know the inputs required for the PID so it is a static module.
-What inputs or outputs my module needs?
This is a processing module all its inputs come from the Tag Bus and all the outputs go into the Tag Bus. The initial channel list is the following one:

Name               | 	Type   |  Direction
--                 |  ---    |--
Temperature        | Double  |  Processing Parameter
Setpoint           | Double  |  Processing Parameter
Output Range High  | Double  |  Processing Parameter   
Output Range Low   | Double  |  Processing Parameter   
Output             | Double  |  Processing Result

This channel list will change during the exercise.



### Part A: Create a Static PID Module
##### Create module from template
1. Navigate to **Project >> Create Project…**
2. In the tree on the left, select **DCAF >> Modules** and select **DCAF Static Channel Module**.
3. Type **Custom Temperature Controller** as the **Module Name**.
4. Look for the Project Root **\\Temperature Controller\Modules** and create a folder called **Custom Temperature Controller**. Get into that folder and press **Current Folder**.
6. Add the following parameters to your new module as **Channels** in the **Channel Specifications** tab. Channels represent data passed to or from your module during different execution stages, and channel names are case sensitive. The direction specifies whether the data is to the module or from the module, and is divided into inputs (data provided by input.vi), outputs (data provided to output.vi), and processing parameters and results (data passed to and from process.vi). For this hands on we will implement a processing step.

Name               | 	Type   |  Direction
--                 |  ---    |--
Temperature        | Double  |  Processing Parameter
Setpoint           | Double  |  Processing Parameter
Output Range High  | Double  |  Processing Parameter   
Output Range Low   | Double  |  Processing Parameter   
Output             | Double  |  Processing Result


Your configuration should look like the one shown in Figure 1.1.

<p align="center">
![Figure 1.1 Custom Temperature Controller Creation.JPG](Pictures\custom_temperature_controller_creation.JPG)
</p>
<p align="center">
*Figure 1.1*
</p>
7.	Press Finish. </br>
 <p align="center">
![Figure 1.2 Custom Temperature Controller Project.JPG](Pictures\custom_temperature_controller_project.JPG)
</p>
<p align="center">
*Figure 1.2*
</p>

8. Your new project will appear. Navigate to **Custom Controller Module runtime.lvclass** and open **user process.vi**. This method should have two clusters, one input and one output, which match the list of tags above. This clusters were created based on the table you just filled in.
<p align="center">
![Figure 1.2 Custom Temperature Controller Project.JPG](Pictures\ctc_new.JPG)
</p>
<p align="center">
*Figure 1.3*
</p>


9.	Open process.vi in the overrides folder.
<p align="center">
![Figure 1.4 Custom Temperature Controller Process.JPG](Pictures\ctc_process.JPG)
</p>
<p align="center">
*Figure 1.4*
</p>
On either side, Scripted Accessors convert tag bus data into your user-defined cluster. These methods are not automatically generated by the project scripting tool and must be generated when the project is first scripted or after any change to the interface. we will cover how to make changes to this VIs in Part B of this exercise. This accessors will look like figure 1.5.
<p align="center">
![Figure 1.4 Custom Temperature Controller Accessors New .JPG](Pictures\ctc_accessors_new.JPG)
</p>
<p align="center">
*Figure 1.4*
</p>


### Part B: Update the Static PID Module with scripting
As with any project requirment changed and we need to set the P,I,D values also through channels in this section we are going to update our module si its channel list matches this table:

Name               | 	Type   |  Direction
--                 |  ---    |--
Temperature        | Double  |  Processing Parameter
Setpoint           | Double  |  Processing Parameter
Output Range High  | Double  |  Processing Parameter   
Output Range Low   | Double  |  Processing Parameter   
P                  | Double  |  Processing Parameter  
I                  | Double  |  Processing Parameter   
D                  | Double  |  Processing Parameter    
Output             | Double  |  Processing Result



1. Update the clusters
2. Run the scripting
a.	Open Tools >> DCAF >> Launch Control Module Scripting Utility…
b.	Drag the runtime class from the project over the runtime class path control or browse for it manually, then repeat for the configuration class (YourModuleName Configuration.lvclass).
c.	Because you used the script, you can leave most options as the default and press Run.

3. Test the user Process



### Part C: Implement the user process
Test
8. 	Your new project will appear. Navigate to **Custom Controller Module runtime.lvclass** and open **user process.vi**. This method should have two clusters, one input and one output, which match the list of tags above. This clusters were created based on the table you just filled in.
<p align="center">
![Figure 1.2 Initial User Process](Pictures\fig_1_2_initial_user_process.jpg)
</p>
<p align="center">
*Figure 1.2*
</p>

9. Implement the same PID control as shown in the Figure 1.3

<p align="center">
![Figure 1.3 Intermediate User Process](Pictures\fig_1_3_intermediate_user_process.jpg)
</p>
<p align="center">
*Figure 1.3*
</p>

<ol type="a">
<li>	Drop down an instance of PID.vi from Control and Simulation >> PID >> PID.vi.
<li>	Drop down the following functions: 1 Unbundle by Name, 2 Bundle functions, 1 Bundle by Name function, and a Select function.</li>
<li>	Wire the Unbundle by Name function to the Parameters to process cluster. Expand all the terminals.</li>
<li>	Wire Parameters to process.Temperature to PID.vi process variable input.</li>
<li>	Wire Parameters to process.setpoint to PID.vi setpoint input.</li>
<li>	Bundle Parameters to process.output range high and Parameters to process.output range low and wire the cluster to PID.vi output range input.</li>
<li>	Bundle Parameters to process.Kc, Parameters to process.Ti, and Parameters to process.Td and wire the cluster to PID.vi PID gains input. </li>
<li>	Create a constant from Results from processing indicator and connect it to the Bundle by Name input cluster terminal. Expand the Unbundle by Name Function to have 2 terminals. </li>
<li>	Wire Parameters to process.Fan on? to the Select function and set the two values as t=100 and f=0. Wire the output of this function to the Results from processing.fan value. </li>
<li>	Wire PID.vi output to Results from processing.lamp. </li>
<li>	The result should look something like Figure 1.3.</li>
</ol>

11.	Save the new project and close it.

### Part C: Running and Configuring the Module

12. Open Standard Configuration Editor (**Open Tools >> DCAF >> Launch Standard Configuration Editor…**).
13.	Navigate to **Tools >> Edit Plugin Search Paths**.
14.	Press Add and navigate to the location of your new control module (**\\Temperature Controller\Module\Custom Temperature Controller**).
15. Open Static Temperature Controller.pfcg in the exercise folder.
16.	Now, right click on Standard Engine and select **Add >> Other>>Custom Controller Module**. Then, select this new module from the tree.
17.	For each processing parameter tag, right click on the column Mapped to System Tag and configure the channel to be mapped to the appropriate system tag. You can look at “Temperature Controller Logic” to identify the correct mapping, which looks like Figure 1.4:
18.
<p align="center">
![Figure 1.4 Intermediate User Process](Pictures\fig_1_4_intermediate_configuration.jpg)
</p>
<p align="center">
*Figure 1.4*
</p>







## Exercise 2:
In this exercise we will create a DCAF Static module that contains a state machine. This is a optional and advance exercise so there are no detailed instructions. To create this module you can use exercise 1 as reference and the DCAF developer guide section 4. There is a solution included in the solutions folder.

#### Concepts Covered:
- Use of runtime class private data
- Module initialization
- Static module parameters

#### Module Definition:
The module will be a simple state machine that contains 3 states. This states will transition from one state to the next only if just the correct Boolean is selected.

The state machine will have simple transitions.
- Change from state 1 to state 2 if only A is True
- Change form state 2 to state 3 if only B is True
- Change from state 3 to state 1 if only C is True


<p align="center">
![Figure 2.1 State Machine Diagram](Pictures\state_machine_state_diagram.jpg)
</p>
<p align="center">

The inputs and outputs list for this modules are:

##### Processing Parameters:
- A : Boolean
- B : Boolean
- C : Boolean

##### Processings Results:
- state 1 : Boolean
- state 2 : Boolean
- state 3 : Boolean

In addition to this the module will have a parameter that defines the initial state:
-initial_state: I32


### Part A: Create the state machine module
1. Create module from template
2. Add the state to the runtime
3. Initialize the state
4. Implement the user process
5. Test the user process stand alone



### Part B: Create a DCAF Application that runs the Static Module
1. Create a new project with the Basic Execution Template
2. Create a new vi for the UI that looks like figure 2.2
3. Create a DCAF configuration that maps the state machine to the UI using the UI modules
4. Run the application and test.
<p align="center">
![Figure 1.2 State Machine UI](Pictures\state_machine_ui.jpg)
</p>
<p align="center">
